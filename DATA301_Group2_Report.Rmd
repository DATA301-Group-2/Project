---
title: "DATA301_Group2_Report"
output: html_document
date: "2025-08-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
```

```{r}
# import dataset from github

url_data <- 'https://raw.githubusercontent.com/DATA301-Group-2/Project/refs/heads/main/FoodAccessResearchAtlasData2019/FoodAccessResearchAtlasData2019.csv'
data <- read.csv(url_data)
head(data)
```

```{r}
# check data types
glimpse(data)
```

The data types in the dataset are mostly incorrect.  The binary variables for flagging low-income and low-access tracts are correctly stored as integers, and the State and County categorical variables are correctly stored as characters.  All of the population count and population share variables, however, are stored as characters.  The count variables should be stored as integers and the share variables as doubles.   

```{r}
# check summary 
summary(data)
```

We can see from the minimums and maximums of the binary variables, along with the fact that we know they are stored as integers, that the only values present in the data set are in fact 0 and 1.  However, there appear to be a lot of missing values in the data set, so we need to check for NAs and other missing data values. 

```{r}
colSums(is.na(data))
``` 

None of the variables have NAs, so it appears that the missing data are all stored as a string, "NULL". 

```{r}

# extract a list of columns with string data
string_cols <- names(data)[sapply(data, is.character)]

# count the number of "NULL" values per column 
null_counts <- sapply(data[string_cols], function(x) sum(x == "NULL"))
print(null_counts)

``` 

Some of the variables have very large proportions of null values, up to 71,025 null values out of 72,531, which leaves only 1,506 data points.  The variables with the highest null values are the 20 mile variables, which we are not using at this point in our project.  Luckily, our response variable LA1and10 has no missing values. Since we are splitting up the data as urban and rural, it is better for us to use the LAPOP1_10 if we want to look at raw population counts, instead of the lapop1 and lapop10 separately, because there is much less missing data for this variable.  Since we will have split the data already using the Urban variable, we will know if we are looking at the population for 1 mile if it is an urban area and 10 miles if it is a rural area. There are still a lot of variables at the 10 mile scale that are missing 64,765 values, leaving only 7,766 data points for analysis. First we must convert the string "NULL" values to true NAs, and convert all of the variables to the appropriate data type. 

```{r}

# check the string_cols
string_cols

# extract only the columns that need to be converted to numeric
numeric_cols <- setdiff(string_cols, c("State", "County"))
numeric_cols

# isolate the true string variables
string_cols <- setdiff(string_cols, numeric_cols)
string_cols

# add remaining columns to numeric_cols for consistency
remaining_cols <- setdiff(names(df), c(string_cols, numeric_cols))
numeric_cols <- c(numeric_cols, remaining_cols)
```

```{r}

# convert data into numeric, simultaneously convert "NULL" to NA
data[numeric_cols] <- lapply(data[numeric_cols], function(x) {
  as.numeric(ifelse(x == "NULL", NA, x))
})

# check data types
glimpse(data)
``` 

Now all of the string data types that represented numeric data have been converted into numeric formats.  We can check the summary statistics again to look for outliers. 


```{r}

# check summary 
summary(data)

``` 

One good thing to note is that there are no share variables over 100, which would be an impossible number.  There are, however, quite a lot of 100% maximums, which are a bit suspicious and require further investigating.  It could be the case that in some tracts with very low populations a 100% is possible, but there are a surprising number of them. 

```{r}
na_counts <- colSums(is.na(data))
na_counts
``` 

```{r}

# check rows missing 4 values
cols_4NAs <- names(na_counts[na_counts == 4])
subset_4NAs <- data[, cols_4NAs]
rows_missing_4 <- apply(is.na(subset_4NAs), 1, all)
rows_missing_4 <- data[rows_missing_4,]
rows_missing_4

``` 

NUMGQT, PCTGQTRS, PovertyRate, MedianFamilyIncome - only 4 missing, three are in the same County, and those are the only three data points for that County.

```{r}

# check rows missing 25 values
cols_25NAs <- names(na_counts[na_counts == 25])
subset_25NAs <- data[, cols_25NAs]
rows_missing_25 <- apply(is.na(subset_25NAs), 1, all)
rows_missing_25 <- data[rows_missing_25,]

``` 

These 25 rows are also missing NUMGQT and PCTGQTRS, so the rows with four missing values are a subset of these.  They are not all from the same State or County, but quite a few are from Madison County in New York. 

```{r}

# check rows missing 4568 values
cols_4568NAs <- names(na_counts[na_counts == 4568])
subset_4568NAs <- data[, cols_4568NAs]
rows_missing_4568 <- apply(is.na(subset_4568NAs), 1, all)
rows_missing_4568 <- data[rows_missing_4568,]
table(rows_missing_4568$Urban)
``` 

These 4,568 rows are all missing LAPOP1_10 and LALOWI1_10, which could be problematic if we wanted to look at those variables.  All but one of them are urban tracts, which could affect the results. The other missing variables are all at the 1/2 mile measurements so they are not of concern for the current scope of this project. 

```{r}
# check rows missing 19989 values
cols_19989NAs <- names(na_counts[na_counts == 19989])
subset_19989NAs <- data[, cols_19989NAs]
rows_missing_19989 <- apply(is.na(subset_19989NAs), 1, all)
rows_missing_19989 <- data[rows_missing_19989,]
table(rows_missing_19989$Urban)
```


These 19,989 rows are also missing LAPOP1_10 and LALOWI1_10, and they are also almost exclusively urban. In addition, they are missing a lot of our variables of interest.  

```{r}
# check rows missing 64765 values
cols_64765NAs <- names(na_counts[na_counts == 64765])
subset_64765NAs <- data[, cols_64765NAs]
rows_missing_64765 <- apply(is.na(subset_64765NAs), 1, all)
rows_missing_64765 <- data[rows_missing_64765,]
table(rows_missing_64765$Urban)
```

There are 64,765 rows that are missing lalowi10, lalowi10share, lakids10, lakids10share, laseniors10, laseniors10share, lawhite10, lawhite10share, lablack10, lablack10share, laasian10, laasian10share, lanhopi10, lahopi10share, laaian10.  They are also disproportionately urban data points. This is potentially problematic depending on the direction we want to go. Luckily the raw population numbers are not missing, just the low-access population numbers.  


Summary Statistics
```{r}
library(dplyr)
library(tidyr)
library(tibble)
library(knitr)
library(kableExtra)


use_mode <- function(x) {
  ux <- na.omit(unique(x))
  ux[which.max(tabulate(match(x, ux)))]
}
```


```{r}

#urban vs rural
data %>%
  group_by(Area = ifelse(Urban == 1, "Urban", "Rural")) %>%
  summarise(
    n_tracts   = n(),
    mean_p   = round(mean(lapop1share, na.rm = TRUE), 2),
    median_p = round(median(lapop1share, na.rm = TRUE), 2),
    sd_p   = round(sd(lapop1share, na.rm = TRUE), 2),
    .groups = "drop"
  ) %>%
  kable(caption = "Urban vs Rural – Low-access population ", align = "c") %>%
  kable_styling(full_width = TRUE, position = "center")

```


```{r}

#income
data %>%
  group_by(Area = ifelse(Urban == 1, "Urban", "Rural")) %>%
  summarise(
    n_tracts   = n(),
    mean_incm   = round(mean(LowIncomeTracts, na.rm = TRUE) * 100, 2),

    sd_incm    = round(sd(LowIncomeTracts, na.rm = TRUE) * 100, 2),
    .groups = "drop"
  ) %>%
  kable(caption = "Urban vs Rural – Low-income tracts (%)", align = "c") %>%
  kable_styling(full_width = TRUE, position = "center")

```





```{r}
# low access - children
data %>%
  group_by(Area = ifelse(Urban == 1, "Urban", "Rural")) %>%
  summarise(
    n_tracts   = n(),
    mean_ch   = round(mean(lakids1share, na.rm = TRUE), 2),
    median_ch = round(median(lakids1share, na.rm = TRUE), 2),
    sd_ch   = round(sd(lakids1share, na.rm = TRUE), 2),
    max_ch    = round(max(lakids1share, na.rm = TRUE), 2),
    .groups = "drop"
  ) %>%
  kable(caption = "Urban vs Rural  Low-access children ") %>%
  kable_styling(full_width = TRUE, position = "center")

```



```{r}

#seniors
data %>%
  group_by(Area = ifelse(Urban == 1, "Urban", "Rural")) %>%
  summarise(
    n_tracts   = n(),
    mean_snrs   = round(mean(laseniors1share, na.rm = TRUE), 2),
    median_snrs = round(median(laseniors1share, na.rm = TRUE), 2),
    sd_snrs    = round(sd(laseniors1share, na.rm = TRUE), 2),
    max_snrs    = round(max(laseniors1share, na.rm = TRUE), 2),
    .groups = "drop"
  ) %>%
  kable(caption = "Urban vs Rural – Low-access seniors", align = "c") %>%
  kable_styling(full_width = TRUE, position = "center")

```


```{r}

#poverty rate
data %>%
  group_by(Area = ifelse(Urban == 1, "Urban", "Rural")) %>%
  summarise(
    n_tracts   = n(),
    mean_pr   = round(mean(PovertyRate, na.rm = TRUE), 2),
    median_pr = round(median(PovertyRate, na.rm = TRUE), 2),
    sd_pr    = round(sd(PovertyRate, na.rm = TRUE), 2),
    mode_pr   = round(use_mode(PovertyRate), 2),
    .groups = "drop"
  ) %>%
  kable(caption = "Urban vs Rural – Poverty rate ", align = "c") %>%
  kable_styling(full_width = TRUE, position = "center")
```



```{r}

#vehicle access
data %>%
  group_by(Area = ifelse(Urban == 1, "Urban", "Rural")) %>%
  summarise(
    n_tracts   = n(),
    mean_h   = round(mean(lahunv1share, na.rm = TRUE), 2),
    median_h = round(median(lahunv1share, na.rm = TRUE), 2),
    sd_h     = round(sd(lahunv1share, na.rm = TRUE), 2),
    max_h    = round(max(lahunv1share, na.rm = TRUE), 2),
    .groups = "drop"
  ) %>%
  kable(caption = "Urban vs Rural Households without vehicles ", align = "c") %>%
  kable_styling(full_width = TRUE, position = "center")
```



```{r}

#correlation key variables
vars <- data %>%
  select(
    `Poverty Rate (%)` = PovertyRate,
    `Median Family Income (USD)` = MedianFamilyIncome,
    `Low-access Population ` = lapop1share,
    `Low-access Children ` = lakids1share,
    `Low-access Seniors ` = laseniors1share,
    `No Vehicle Households ` = lahunv1share
  )


cor_matrix <- round(cor(vars, use = "pairwise.complete.obs", method = "spearman"), 2)


knitr::kable(cor_matrix, caption = "Correlation Matrix of Key Variables") %>%
  kable_styling(full_width = FALSE, position = "center")
```




Check univariate plots for distributions

```{r}
library(ggplot2)
library(dplyr)

data <- data %>%
  mutate(
    LAPOP1_10 = as.numeric(LAPOP1_10),
    Urban = as.numeric(Urban),
    Pop2010 = as.numeric(Pop2010),
    Rural = Pop2010 - Urban,                # derive rural population
    TractKids = as.numeric(TractKids),      # under 18
    TractSeniors = as.numeric(TractSeniors) # 65+
  )

### Distribution of LAPOP1_10 (response variable)
ggplot(data, aes(x = LAPOP1_10)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white", alpha = 0.7) +
  geom_density(aes(y = ..count..), color = "red", linewidth = 1) +
  theme_minimal() +
  labs(title = "Distribution of LAPOP1_10", x = "LAPOP1_10", y = "Count")

ggplot(data, aes(x = factor(Urban))) +
  geom_bar(fill = "orange", alpha = 0.7) +
  theme_minimal() +
  labs(title = "Distribution of Urban Population", x = "Urban", y = "Count")

### Distribution of Rural population
ggplot(data, aes(x = Rural)) +
  geom_histogram(bins = 30, fill = "sienna", color = "white", alpha = 0.7) +
  theme_minimal() +
  labs(title = "Distribution of Rural Population", x = "Rural", y = "Count")

### Distribution of Age groups (Kids and Seniors)
ggplot(data, aes(x = TractKids)) +
  geom_histogram(bins = 30, fill = "purple", color = "white", alpha = 0.7) +
  theme_minimal() +
  labs(title = "Distribution of Children (<18)", x = "TractKids", y = "Count")

ggplot(data, aes(x = TractSeniors)) +
  geom_histogram(bins = 30, fill = "orange", color = "white", alpha = 0.7) +
  theme_minimal() +
  labs(title = "Distribution of Seniors (65+)", x = "TractSeniors", y = "Count")
```

```{r}
ggplot(data, aes(y = LAPOP1_10)) +
  geom_boxplot(fill = "skyblue") +
  theme_minimal() +
  labs(title = "Boxplot of LAPOP1_10", y = "LAPOP1_10")

ggplot(data, aes(x = factor(LowIncomeTracts))) +
  geom_bar(fill = "orange", alpha = 0.7) +
  theme_minimal() +
  labs(title = "Distribution of Low Income Tracts", x = "LowIncomeTracts (0/1)", y = "Count")

```


Plots 

```{r}

#age groups (children, seniors) urban vs rural

# children
ggplot(data, aes(x = ifelse(Urban == 1, "Urban", "Rural"),
                       y = lakids1share)) +
  geom_boxplot(fill = "brown") +
  labs(title = "Children with Low Access Urban vs Rural",
       x = "Area", y = "children with low access (%)")

# seniors
ggplot(data, aes(x = ifelse(Urban == 1, "Urban", "Rural"),
                       y = laseniors1share)) +
  geom_boxplot(fill = "navy") +
  labs(title = "Seniors with Low Access Urban vs Rural)",
       x = "Area", y = "seniors with low access (%)")


```

```{r}
# vehicle access urban vs rural

ggplot(data, aes(x = ifelse(Urban == 1, "Urban", "Rural"),
                       y = lahunv1share)) +
  geom_boxplot(fill = "blue") +
  labs(title = "Vehicle Access in Urban vs Rural",
       x = "Area", y = "Vehicle Access (%)")
```


```{r}

#average Low-Access by State  
avrge_by_state <- data %>%
  mutate(Area = ifelse(Urban == 1, "Urban", "Rural")) %>%
  group_by(State, Area) %>%
  summarise(lowaccess = mean(lapop1share, na.rm = TRUE), .groups = "drop") %>%
  mutate(region = tolower(State))

us_map <- map_data("state")
avrge_by_state <- avrge_by_state %>% filter(region %in% unique(us_map$region))  
plot_df  <- left_join(us_map, avrge_by_state, by = "region")

ggplot(plot_df, aes(long, lat, group = group, fill = lowaccess)) +
  geom_polygon(color = "white", linewidth = 0.3) +
  coord_fixed(1.3) +
  facet_wrap(~ Area) +
  scale_fill_gradient(low = "lightyellow", high = "darkred", name = "Low access") +
  labs(title = "Average Low-Access by State  Urban vs Rural") +
  theme_void()
```

```{r}
# group quarters urban vs rural

ggplot(data, aes(x = ifelse(Urban == 1, "Urban", "Rural"),
                       y = PCTGQTRS)) +
  geom_boxplot(fill = "purple") +
  labs(title = "Group Quarters Low Access in Urban vs Rural",
       x = "Area", y = "Group Quarters (%)")
```

```{r}

#Median Family Income
ggplot(data, aes(x = MedianFamilyIncome, y = lapop1share)) +
  geom_point(alpha = 0.4, color = "orange") +
  facet_wrap(~ ifelse(Urban == 1, "Urban", "Rural")) +
  labs(title = " Median Income in low Access urban vs rural areas ",
       x = "Median Family Income (USD)", y = "Low Access(%)") +
  theme_minimal()
```

```{r}
# low income urban vs rural

ggplot(data, aes(x = ifelse(Urban == 1, "Urban", "Rural"),
                       y = lalowi1share)) +
  geom_boxplot(fill = "pink") +
  labs(title = "Low Income and Low Access in Urban vs Rural",
       x = "Area", y = "Low Income (%)")
```



Regression
```{r}

#poverty regression
ggplot(data, aes(x = PovertyRate, y = lapop1share)) +
  geom_point(alpha = 0.4, color = "steelblue") +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  facet_wrap(~ ifelse(Urban == 1, "Urban", "Rural")) +
  labs(title = "Poverty Rate vs Low Access Population by Area ",
       x = "Poverty Rate (%)",
       y = "% Low-Access Population") +
  theme_minimal()
```

```{r}
# Median Family Income Regression 

ggplot(data, aes(x = MedianFamilyIncome, y = lapop1share)) +
  geom_point(alpha = 0.4, color = "steelblue") +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  facet_wrap(~ ifelse(Urban == 1, "Urban", "Rural")) +
  labs(title = "Median Family Income vs Low Access Population by Area ",
       x = "Median Family Income (%)",
       y = "% Low-Access Population") +
  theme_minimal()
```

```{r}
# names of race codes in data set for looping
race_vars <- c("White", "Black", "Asian", "NHOPI", "AIAN", "OMultir", "Hispanic")

# create dataframe for plotting, pivot longer
plot_df <- data %>%
  mutate(Area = ifelse(Urban == 1, "Urban", "Rural")) %>%
  select(Area, Pop2010, paste0("Tract", race_vars)) %>%
  pivot_longer(cols = starts_with("Tract"), 
               names_to = "Race", 
               values_to = "Count") %>%
  mutate(Race = gsub("Tract", "", Race))

# group and get counts
summary_df <- plot_df %>%
  group_by(Area, Race) %>%
  summarise(total_people = sum(Count, na.rm = TRUE), .groups = "drop")

# change to percentages
summary_pct <- summary_df %>%
  group_by(Area) %>%
  mutate(pct = 100 * total_people / sum(total_people))

ggplot(summary_pct, aes(x = Race, y = pct, fill = Race)) +
  geom_col(alpha = 0.8) +
  facet_wrap(~Area, ncol = 2) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "Racial Composition in Urban vs Rural Areas",
    x = "Race",
    y = "Percentage of Population"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1))
```



```{r}
# loop through the 7 race categories 
for (race in race_vars) {
  race_col <- paste0("Tract", race)
  pct_col <- paste0("pct_", race)
  
  data <- data %>%
    mutate(!!pct_col := 100 * !!sym(race_col) / Pop2010)
  
  # plot % population race vs. % population low-access
  p <- ggplot(data, aes_string(x = pct_col, y = "lashare", color = "Area")) +
    geom_smooth(method = "loess", se = TRUE, span = 0.8) +
    facet_wrap(~Area) +
    labs(
      title = paste0("Smoothed Relationship Between % ", race, " and % Low-Access"),
      x = paste0("% ", race, " Population"),
      y = "% Low-Access Population"
    ) +
    scale_color_manual(values = c("Urban" = "#1f78b4", "Rural" = "#33a02c")) +
    scale_x_continuous(limits =c(0,100)) +
    scale_y_continuous(limits =c(0,100))
    theme_minimal(base_size = 14)
  
  print(p)
}
```

```{r}
# new data frame for SNAP status
snap_df <- data %>%
  mutate(
    Area = ifelse(Urban == 1, "Urban", "Rural"),
    SNAP_on = TractSNAP,
    SNAP_off = OHU2010 - TractSNAP
  ) %>%
  select(Area, SNAP_on, SNAP_off) %>%
  pivot_longer(
    cols = c(SNAP_on, SNAP_off),
    names_to = "SNAP_Status",
    values_to = "Households"
  ) %>%
  mutate(SNAP_Status = ifelse(SNAP_Status == "SNAP_on", "On SNAP", "Not on SNAP"))

# calculate percentages by rural and urban
summary_snap <- snap_df %>%
  group_by(Area, SNAP_Status) %>%
  summarise(total_households = sum(Households, na.rm = TRUE), .groups = "drop") %>%
  group_by(Area) %>%
  mutate(pct = 100 * total_households / sum(total_households))

# plot % households on SNAP by urban and rural
ggplot(summary_snap, aes(x = SNAP_Status, y = pct, fill = SNAP_Status)) +
  geom_col(alpha = 0.8) +
  facet_wrap(~Area, ncol = 2) +
  scale_fill_manual(values = c("On SNAP" = "#e41a1c", "Not on SNAP" = "#377eb8")) +
  labs(
    title = "Percentage of Households on SNAP Benefits in Urban vs Rural Areas",
    x = "SNAP Status",
    y = "Percentage of Households"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```


```{r}
# create dataframe with percentages
plot_snap <- data %>%
  mutate(
    Area = ifelse(Urban == 1, "Urban", "Rural"),
    pct_snap = 100 * TractSNAP / OHU2010,
    lashare = 100 * LAPOP1_10 / Pop2010
  )

# plot of low-access vs % SNAP by urban vs. rural
ggplot(plot_snap, aes(x = pct_snap, y = lashare)) +
  geom_smooth(method = "loess", se = TRUE, span = 0.8, color = "#1f78b4") +
  facet_wrap(~Area, ncol = 2, strip.position = "top") +
  scale_x_continuous(limits = c(0, 100)) +
  scale_y_continuous(limits = c(0, 100)) +
  labs(
    title = "% Low-Access Population vs % Households on SNAP",
    x = "% Households on SNAP",
    y = "% Low-Access Population"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    strip.text = element_text(face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```


```{r}
# remove NAs and bin PovertyRate into 5% bins
poverty_df <- data %>%
  filter(!is.na(PovertyRate)) %>%
  mutate(
    Area = ifelse(Urban == 1, "Urban", "Rural"),
    PovertyBin = cut(PovertyRate,
                     breaks = seq(0, 100, by = 5),
                     include.lowest = TRUE,
                     right = FALSE)
  ) %>%
  # only include up to 55-60% because that was the max
  filter(as.numeric(PovertyBin) <= 12)  

# calculate percentages by urban vs rural
summary_poverty <- poverty_df %>%
  group_by(Area, PovertyBin) %>%
  summarise(n_tracts = n(), .groups = "drop") %>%
  group_by(Area) %>%
  mutate(
    pct = 100 * n_tracts / sum(n_tracts),
    # convert factor bin to numeric midpoint for smoothing
    BinMid = as.numeric(sub("\\[(\\d+),.*", "\\1", PovertyBin)) + 2.5
  )

# bar chart 
ggplot(summary_poverty, aes(x = BinMid, y = pct, fill = PovertyBin)) +
  geom_col(alpha = 0.8) +
  facet_wrap(~Area, ncol = 2) +
  scale_fill_brewer(palette = "YlOrRd") +
  scale_x_continuous(breaks = seq(0, 60, by = 5), limits = c(0, 60)) +
  labs(
    title = "Distribution of Poverty Rate by Urban vs Rural Areas",
    x = "Poverty Rate (%)",
    y = "Percentage of Tracts"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

```{r}
# create df without NAs and with low-access percentages
plot_poverty <- data %>%
  mutate(
    Area = ifelse(Urban == 1, "Urban", "Rural"),
    lashare = 100 * LAPOP1_10 / Pop2010
  ) %>%
  filter(!is.na(PovertyRate))  # remove NAs

#  plot low-access vs PovertyRate by urban vs. rural
ggplot(plot_poverty, aes(x = PovertyRate, y = lashare)) +
  geom_smooth(method = "loess", se = TRUE, span = 0.8, color = "#1f78b4") +
  facet_wrap(~Area, ncol = 2, strip.position = "top") +
  scale_x_continuous(limits = c(0, 100)) +
  scale_y_continuous(limits = c(0, 100)) +
  labs(
    title = "% Low-Access Population vs % Population in Poverty",
    x = "% Population in Poverty",
    y = "% Low-Access Population"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    strip.text = element_text(face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

